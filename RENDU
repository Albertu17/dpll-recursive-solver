                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 3 novembre 2023, 23h59

Identité
--------
Nombre de binôme: 16
Nom, prénom 1: Tomasi, Albert
Nom, prénom 2: De Larminat, Foucauld


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, nous avons testé ces commandes. 'make dpll' s'exécute sans erreurs ou
warnings et le résultat './dpll sudoku-4x4.cnf' correspond précisément à
celui attendu.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, nous avons utilisé la fonction 'filter_map' dans notre implémentation
de 'simplifie'.
Notre fonction 'simplifie' déclare une fonction imbriquée 'simplifieClause'
(int list -> int list option) qui opère sur une seule clause. En notant cl
la clause qui lui est passée en argument et l le littéral par lequel on
cherche à simplifier l'ensemble de clauses, 'simplifieClause' fonctionne
de la manière suivante:
   . si cl contient l, elle renvoie None;
   . si cl contient -l, elle renvoie Some(cl privée de -l);
   . sinon, elle renvoie Some(cl).
La fonction 'simplifie' correspond ensuite dans notre implémentation au
résultat de l'application de 'simplifieClause' sur l'ensemble des clauses
par 'filter_map'.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

Nous n'avons pas utilisé de fonction auxiliaire dans notre implémentation
de la fonction 'unitaire'. Celle-ci parcourt la liste de clauses qui lui 
est passée en argument, et vérifie pour chaque élément si il correspond à
une clause unitaire par pattern matching. Si c'est le cas, le littéral 
constituant cette clause est renvoyé. Si toute la liste a été parcourue,
l'exception Not_found est levée.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Fonction auxillaire ajouté : searchPur

La fonction searchPur prends en paramtères : 
	- une liste préallablement aplatie, pour simplifier les parcours
	- un int pour indiquer l'index du littéral que l'on cherche à déterminer si il est pur ou non. A chaque appel récursif, ce litéral est incrémenté de 1.
	- un int pour indiquer la length de la liste passé en paramètre. Ceci évite de devoir re-calculer la longueur à chaque itération de cette fonction.

Cette fonction auxiliaire compare le littéral correspondant à l'index passé en 2eme paramètre à tous les autres nombres de la liste. 

- Si son inverse n'existe pas dans la liste, alors le littéral est pur, et est renvoyé par la fonction, qui s'arrête donc ici (on évite donc de parcourir toute la liste si l'on à déjà un littéral pur sous la main).

- Si son inverse existe dans la liste, ce littéral n'est donc pas pur, et la fonction s'appelle elle même en incrémentant l'index appellé de 1. Si l'index + 1 est supérieur à la longueur de la lsite (donc si List.nth index l retournerait Failure nth), alors l'on considère qu'il n'y a aucun littéral pur dans la liste, et elle lève donc une exception (Failure "pas de littéral pur").


La fonction pur, elle, prends en paramètre une liste de liste, la flatten à l'aide de List.flatten, et appelle searchPur sur le littéral d'index 0 dans cette liste. Elle lève (Failure "pas de littéral pur") si il n'existe pas de litéral pur dans cette liste. 

Fonctions auxillaires utilisés : 

List.find_opt
List.length 

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

La formule correspondant à l'exemple 7_2 ({(1,-1,-3);(-2,3);(-2)}) est
évaluée comme satisfiable par les deux solveurs, mais ces derniers ne
donnent pas la même interprétation comme premier exemple de
satisfiabilité:
   . solveur_split donne comme exemple les valeurs 1, -2 et une valeur
   indifférente pour 3.
   . solveur_dpll_rec donne comme exemple les valeurs -2, -3 et une
   valeur indifférente pour 1.
Cette différence s'explique par le fait que solveur_split commence
par appliquer la règle split avec 1, tandis que solveur_dpll_rec commence
par appliquer la règle unit, ce qui entraîne une simplification par -2.
De manière générale, la principale différence entre les deux solveurs
est l'application supplémentaire des règles unit et pure avant celle
de la règle split dans le solveur dpll.

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--