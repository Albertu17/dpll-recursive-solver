                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 3 novembre 2023, 23h59

Identité
--------
Nombre de binôme: 16
Nom, prénom 1: Tomasi, Albert
Nom, prénom 2: De Larminat, Foucauld


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, nous avons testé ces commandes. 'make dpll' s'exécute sans erreurs ou
warnings et le résultat './dpll sudoku-4x4.cnf' correspond précisément à
celui attendu.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, nous avons utilisé la fonction 'filter_map' dans notre implémentation
de 'simplifie'.
Notre fonction 'simplifie' déclare une fonction imbriquée 'simplifieClause'
(int list -> int list option) qui opère sur une seule clause. En notant cl
la clause qui lui est passée en argument et l le littéral par lequel on
cherche à simplifier l'ensemble de clauses, 'simplifieClause' fonctionne
de la manière suivante:
   . si cl contient l, elle renvoie None;
   . si cl contient -l, elle renvoie Some(cl privée de -l);
   . sinon, elle renvoie Some(cl).
La fonction 'simplifie' correspond ensuite dans notre implémentation au
résultat de l'application de 'simplifieClause' sur l'ensemble des clauses
par 'filter_map'.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

Nous n'avons pas utilisé de fonction auxiliaire dans notre implémentation
de la fonction 'unitaire'. Celle-ci parcourt la liste de clauses qui lui 
est passée en argument, et vérifie pour chaque élément si il correspond à
une clause unitaire par pattern matching. Si c'est le cas, le littéral 
constituant cette clause est renvoyé. Si toute la liste a été parcourue,
l'exception Not_found est levée.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Fonction auxillaire ajouté : searchPur

Cette fonction récursive cherche si la liste (préalablement aplatie par pur) 
prise en paramètre contient l'inverse du premier littéral.

Si non : ce littéral est donc pur, et est renvoyé. 
Si oui : ce littéral n'est donc pas pur. La fonction searchPur est donc 
appellé avec un flitrage sur la liste d'origine moins toutes les instances 
du littéral (il est pur, donc par besoin de le vérifier) ainsi que toutes 
les instances de son inverse (ils sont par définition, aussi purs). 

L'on évite donc le double, triple, quadruple ... comptage, ce qui compense 
bien l'utilisation de List.filter en terme de complexité, surtout pour des 
formules avec beaucoup de clauses / répétition du même littéral à travers 
toutes les clauses. 

Pour éviter de devoir recalculer la longueur de la liste à chaque récursion, 
l'on part du principe que si List.hd échoue (et lève donc une (Failure hd), 
alors la liste de contient pas de littéral (puisqu'ils ont tous été éliminés 
par List.filter). La fonction pur lève donc une exception 
(Failure "pas de littéral pur") 
---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

La formule correspondant à l'exemple 7_2 ({(1,-1,-3);(-2,3);(-2)}) est
évaluée comme satisfiable par les deux solveurs, mais ces derniers ne
donnent pas la même interprétation comme premier exemple de
satisfiabilité:
   . solveur_split donne comme exemple les valeurs 1, -2 et une valeur
   indifférente pour 3.
   . solveur_dpll_rec donne comme exemple les valeurs -2, -3 et une
   valeur indifférente pour 1.
Cette différence s'explique par le fait que solveur_split commence
par appliquer la règle split avec 1, tandis que solveur_dpll_rec commence
par appliquer la règle unit, ce qui entraîne une simplification par -2.
De manière générale, la principale différence entre les deux solveurs
est l'application supplémentaire des règles unit et pure avant celle
de la règle split dans le solveur dpll.

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

Nous n'avons pas cherché à optimiser la fonction solveur_split dans le code.
 
Aujourd'hui, si le solveur ne peut appliquer pur ou unitary aux clauses, il 
test avec solveur_split (l) OR solveur_split(-l), 
avec l étant le premier littéral de la première sous-clause. Or ce littéral 
n'a a priori pas plus de chance de résoudre rapidement l'arbre généré par 
DPLL que n'importe quel autre littéral. 

L'on pourrait imaginer qu'il serait intéressant de prioriser les littéraux 
qui apparaissent le plus grand nombre de fois : l'on pourrait donc simplifier 
plus vite l'ensemble des clauses, et donc arriver à une interprétation 
(satisfiable ou non) plus rapidement. 
L'on pourrait donc imaginer une fonction auxillaire qui recense les nombre 
d'occurences de tous les littéraux (et de leurs inverses) à l'aide d'une map qui 
associe (|litéral| : (nombre d'occurences de l) + (nombre d'occurences de -l)).
Le littéral choisi pour splitter pourrait être celui avec le plus d'occurences. 

La fonction solveur_split aurait aussi besoin d'être modifié pour permettre de 
prendre cette liste en entrée, afin de ne pas devoir la recalculer à chaque fois. 
Il faudrait aussi la mettre à jour à chaque appel réussi à pur/ unitaire / 
solveur_dpll_rec.

L'on pourrait aussi imaginer prioriser les litéraux contenus dans les clauses les 
plus petites, afin de rapidement sur des clauses comme [l];[-l], permettant 
d'invalider le split au plus vite, et éviter des opérations couteuses dans le 
futur. 

Pour ce faire, il faudrait mettre en place une liste des plus petites clauses, 
à update à chaque appel réussi à pur/ unitaire / solveur_dpll_rec, et passage en 
paramètre à solveur_dpll_rec.


---

--fin du fichier RENDU--